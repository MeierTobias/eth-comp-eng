\section{Kernel}
\subsection{Memory Management}
\begin{itemize}
    \item Memory is usually DRAM (capacitory that need to be refreshed periodically)
    \item Last parallel bus (64/72 Bit) in modern computers
\end{itemize}


\subsubsection{Memory Sections}
Kernel allocates code/stack at program start. Heap is allocated dynamically by the kernel and managed by the heap allocator library (e.g. \textit{heap.so}, part of application).

\ptitle{.text}

\begin{itemize}
    \item Generated by compiler
    \item Code (machine instructions)
    \item Does not change after the program ist written (except browser)
\end{itemize}


\ptitle{.data/.bss}

\begin{itemize}
    \item Generated by compiler
    \item \textit{.data}: initialized global vars, static function vars (sizes known beforehand)
    \item \textit{.bss}: same as above but not initialized: allocate a zero page and point to it (no physical memory usage)
\end{itemize}

\ptitle{Stack}

\begin{itemize}
    \item Compiler manages fixed-size Stack
    \item Local variables, callee-saved registers, return address
\end{itemize}

\ptitle{Heap}
\begin{lstlisting}[language={C}]
    void *ptr = malloc(size_t);
    free(ptr);                  
\end{lstlisting}
\begin{itemize}
    \item User steers lifetime (new, delete)
    \item Available across functions
    \item Used also for large allocations
\end{itemize}

\paragraph{Managing Code and Stack}



\subsubsection{Managing the Heap}
\begin{itemize}
    \item Heap suffers \textbf{fragmentation} at runtime: causes non-contiguous memory
          \noindent\begin{itemize}
              \item External fragmentation is caused by disadvantageous sequences of allocations/freeings (there would be enough free heap but it is not contiguous)
              \item Internal fragmentation is caused by having large heap units where small allocations waste memory
          \end{itemize}
    \item Fragmentation and finding free memory must be handeled
    \item \textbf{Heap metadata} are used to keep track of free memory and for sanity checks
          \noindent\begin{itemize}
              \item In-band heap metadata are stored inside the heap
              \item Out-of-band heap metadata are kept ouside the heap
          \end{itemize}
\end{itemize}

\subsubsection{In-Band Metadata: Linked List}
\begin{itemize}
    \item Use a linked list to keep track of \textbf{free} heap sections
    \item Nodes stored at start of each free heap section
    \item Stores size of allocation, pointer to next node, magic variable for sanity check
\end{itemize}

\begin{lstlisting}[language={C}]
    typedef struct __node_t {
        int size;                       // allocation size
        union {
            int magic;                  // sanity check
            struct __node_t *next;      // next free section
        } u;
    } node_t;         
\end{lstlisting}

\ptitle{Freeing Heap}

\begin{itemize}
    \item \lstinline{free(a)}
    \item Allocate a new \lstinline{__node_t} data structure
    \item Check if magic value has not been overwritten
    \item Let \lstinline{ __node_t *next} point to previous \lstinline{head}
    \item Make the new node the new \lstinline{head}
\end{itemize}

\ptitle{Selecting Free Heap}

\begin{itemize}
    \item Walk the linked list at \lstinline{malloc()}
    \item \textbf{First fit}: take first free slot that is big enough
    \item \textbf{Best fit}: take slot matching the required size the best (slow: walk entire list)
    \item Counterintuitively, first fit uses space more efficiently than best fit (small losses at each allocation!)
    \item As slot is selected: remove corrsponding node from list, update pointers, return pointer to free heap
\end{itemize}

\ptitle{Handling Fragmentation}

\begin{itemize}
    \item Coalesce the free list
    \item Walk the list, find adjacent free items and merge them
\end{itemize}

\subsubsection{Out-Of-Band Metadata: Bitmap-Based Allocations}
\begin{itemize}
    \item Every bit can tell whether N bytes of the heap are free
    \item \lstinline{malloc()} scans the bitmap for free space
    \item \lstinline{free()} flips the right bits in the bitmap to zero
    \item One needs \textbf{additional} data to keep track of the total allocation sizes (as we only know status of our N byte units)
\end{itemize}

\ptitle{Fragmentation vs. Performance}
\begin{itemize}
    \item Coalescing is very cheap (flipping bits)
    \item \lstinline{malloc()} is more expensive (scan the bitmap), depending on how coarse the bitmap is
    \item In a fine bitmap one has precise allocations (low internal fragmentation) but expensive \lstinline{malloc()}
    \item In a coarse bitmap one has more bytes per bit, hence less precise allocations (high internal frag) but cheap \lstinline{malloc()}
\end{itemize}


\subsubsection{In-/Out-Of-Band Megadata: Slab Allocation}

\begin{itemize}
    \item Create ``sub-heaps'' for commonly used allocation sizes
\end{itemize}


\subsubsection{Page Allocation: Buddy Allocator}
Page Allocation optimizes for \textbf{maximal usage}.

