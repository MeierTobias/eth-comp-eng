\section{Assembler}
\subsection{Interaction with Memory}
The CPU uses 32-bit sized instructions to
\begin{enumerate}[leftmargin=20pt]
    \item read memory (DRAM) into registers if needed
    \item execute computation using registers
    \item write the changed registers back into memory (DRAM)
\end{enumerate}

\newpar{}
\textbf{Remark:} While the CPU always uses 32-bit sized instructions to access memory,
the address space can be larger:

\renewcommand{\arraystretch}{1.3}
\setlength\tabcolsep{6pt} % default value: 6pt
\begin{tabularx}{\linewidth}{@{}lll@{}}
    Name        & Register size & Address space          \\
    \cmidrule{1-3}
    \code{RV32} & 32 bit        & $2^{32} \simeq 4$ Gbit \\
    \code{RV64} & 64 bit        & $2^{64} \gg 1$ Pbit    \\
\end{tabularx}
\renewcommand{\arraystretch}{1}
\setlength\tabcolsep{6pt} % default value: 6pt

\subsection{Signedness}
$n$ bits can either represent [0,$2^{n}-1$] \textbf{unsigned} or [$-2^{n-1}, 2^{n-1}$] \textbf{signed} numbers.
For \textbf{signed} numbers the \textbf{two's complement}
\noindent\begin{equation*}
    -a_{n-1}\cdot2^{n-1}+\sum_{i=0}^{n-2}a_{i}\cdot 2^{i}
\end{equation*}
is used, which allows for addition and subtraction with only one command.

\ptitle{Hint:} To calculate the 2's compliment by hand just invert all the bits and add 1.

\subsection{Big-/ Little-Endian}
A given register \code{t1 = [{\color{blue}0xAA},{\color{magenta}0xBB}]} can be represented in memory as

\begin{tikzpicture}

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw = none,
        text = black,
        fill = gray!20] (r) at (0,0) {};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,
        fill = blue!40] (r) at (30pt,0) {\fncode{0xAA}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,] at (30pt,12pt) {\fncode{t1}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,
        fill = magenta!40] (r) at (60pt,0) {\fncode{0xBB}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw = none,
        text = black,
        fill = gray!20] (r) at (90pt,0) {};

    \node[rectangle,
        anchor = west,
        text height = 6pt,
        draw=none,
        text = black,] at (110pt,0pt) {\fncode{DRAM (big-endian)}};

\end{tikzpicture}

\begin{tikzpicture}

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw = none,
        text = black,
        fill = gray!20] (r) at (0,0) {};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,
        fill = magenta!40] (r) at (30pt,0) {\fncode{0xBB}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,] at (30pt,12pt) {\fncode{t1}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw=none,
        text = black,
        fill = blue!40] (r) at (60pt,0) {\fncode{0xAA}};

    \node[rectangle,
        text width = 30pt,
        text height = 6pt,
        draw = none,
        text = black,
        fill = gray!20] (r) at (90pt,0) {};

    \node[rectangle,
        anchor = west,
        text height = 6pt,
        draw=none,
        text = black,] at (110pt,0pt) {\fncode{DRAM (little-endian)}};

\end{tikzpicture}

RISC-V uses little-endian.


\subsection{Conditional branches}
Conditional branches let the PC jump to a specified line relative to the current position if the given condition holds.

\includegraphics[width=0.7\linewidth]{conditional_branches.png}

\begin{itemize}
    \item 12 bits to branch ``around''
    \item Immediate is always multiplied by 2
    \item Branch backward or forward: [PC + 4KB, PC - 4KB]
\end{itemize}

\subsubsection{Basic If-Statement}

\setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{2pt}
\begin{tabular}[width=\linewidth]{p{0.48\linewidth} p{0.48\linewidth}}
    C++
    \begin{lstlisting}[escapechar=@]
if(@\aftergroup\magentacodecolor@condition == true@\aftergroup\blackcodecolor@){
    // do something
} else {
    // do something else
}\end{lstlisting}
     &
    RISC-V
    \begin{lstlisting}[escapechar=@]
@\aftergroup\magentacodecolor@bne a0, a1, else_label@\aftergroup\blackcodecolor@
# do something
beq zero, zero, out_label

else_label:
# do something else

out_label:
\end{lstlisting}
\end{tabular}
\setlength{\tabcolsep}{\oldtabcolsep}

\subsubsection{Basic For-Loop}

\setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{2pt}
\begin{tabular}[width=\linewidth]{p{0.48\linewidth} p{0.48\linewidth}}
    C++
    \begin{lstlisting}[escapechar=@]
@\aftergroup\olivecodecolor@for@\aftergroup\blackcodecolor@(@\aftergroup\magentacodecolor@i = 0@\aftergroup\blackcodecolor@; @\aftergroup\cyancodecolor@i < size@\aftergroup\blackcodecolor@; @\aftergroup\purplecodecolor@++i@\aftergroup\blackcodecolor@){
    // do something
}
\end{lstlisting}
     &
    RISC-V
    \begin{lstlisting}[escapechar=@]
# a1 = size
    @\aftergroup\magentacodecolor@add t0, zero, zero@\aftergroup\blackcodecolor@
@\aftergroup\olivecodecolor@loop:@\aftergroup\blackcodecolor@
    @\aftergroup\cyancodecolor@bge t0, a1, exit@\aftergroup\blackcodecolor@
    # do something
    @\aftergroup\purplecodecolor@addi t0, t0, 1@\aftergroup\blackcodecolor@
    @\aftergroup\olivecodecolor@beq zero, zero, loop@\aftergroup\blackcodecolor@
exit:
\end{lstlisting}
\end{tabular}
\setlength{\tabcolsep}{\oldtabcolsep}

\subsubsection{Optimized For-Loop}
\setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{2pt}
\begin{tabular}[width=\linewidth]{p{0.48\linewidth} p{0.48\linewidth}}
    C++
    \begin{lstlisting}[escapechar=@]
@\aftergroup\olivecodecolor@for@\aftergroup\blackcodecolor@(@\aftergroup\magentacodecolor@arr_end = arr + size@\aftergroup\blackcodecolor@; @\aftergroup\cyancodecolor@arr++ < arr_end@\aftergroup\blackcodecolor@;){
    // do something
}
\end{lstlisting}
     &
    RISC-V
    \begin{lstlisting}[escapechar=@]
# a0 = arr
# a1 = size
    @\aftergroup\magentacodecolor@add a1, a0, a1@\aftergroup\blackcodecolor@
@\aftergroup\olivecodecolor@loop:@\aftergroup\blackcodecolor@
    @\aftergroup\cyancodecolor@bge a0, a1, exit@\aftergroup\blackcodecolor@
    # do something
    @\aftergroup\purplecodecolor@addi a0, a0, 1@\aftergroup\blackcodecolor@
    @\aftergroup\olivecodecolor@beq zero, zero, loop@\aftergroup\blackcodecolor@
exit:
\end{lstlisting}
\end{tabular}
\setlength{\tabcolsep}{\oldtabcolsep}

\subsection{Useful Instructions}
RISC-V instruction set architecture (isa) \code{RV32I} can be found in Section\ \ref{riscv_isa}.

\newpar{}
\ptitle{Bitwise Invertion}

\begin{lstlisting}[language={[RISC-V]Assembler}]
addi    a1,zero, -1         # create 0b11...111
xor     a0,a0,a1            # xor with 0b11..11
\end{lstlisting}

\newpar{}
\ptitle{64-bit extension}

\begin{lstlisting}[language={[RISC-V]Assembler}]
slli    a0,a0,0x3f      
srai    a0,a0,0x3f          # 64 bit extended mask of a0
\end{lstlisting}

\newpar{}
\ptitle{Load and Store with Offset}

\begin{lstlisting}[language={[RISC-V]Assembler}]
# a0 = base address
# a1 = offset
slli    a1,a1,0x2           # multiply offset by 4 (byte) 
                            # <- 32-bit integer
add     a2,a0,a1            # offset address

lw      a3,0(a2)            # load from offset address
addi    a3,a3,0x1           # increment by one
sw      a3,0(a2)            # store to offset address
\end{lstlisting}