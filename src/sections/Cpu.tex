\begin{center}
    \includegraphics[width=.7\linewidth]{cpu_flowchart.png}
\end{center}

\begin{multicols*}{3}
    \section{CPU Design}\label{cpu design}
    \subsection{Opcode}

    \begin{footnotesize}
        \renewcommand{\arraystretch}{1.2}
        \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}
        \begin{tabularx}{\linewidth}{@{}T T Z Z Z Z @{}}                                                               \\
                                                                  & Signal name & R-format & lw & sw & beq \\
            \cmidrule{2-6}
            \multirow{7}{*}{\begin{sideways}Input\end{sideways}}  & I[6]        & 0        & 0  & 0  & 1   \\
                                                                  & I[5]        & 1        & 0  & 1  & 1   \\
                                                                  & I[4]        & 1        & 0  & 0  & 0   \\
                                                                  & I[3]        & 0        & 0  & 0  & 0   \\
                                                                  & I[2]        & 0        & 0  & 0  & 0   \\
                                                                  & I[1]        & 1        & 1  & 1  & 1   \\
                                                                  & I[0]        & 1        & 1  & 1  & 1   \\
            \cmidrule{2-6}
            \morecmidrules\cmidrule{2-6}
            \multirow{6}{*}{\begin{sideways}Output\end{sideways}} & ALUSrc      & 0        & 1  & 1  & 0   \\
                                                                  & MemtoReg    & 0        & 1  & X  & X   \\
                                                                  & RegWrite    & 1        & 1  & 0  & 0   \\
                                                                  & MemRead     & 0        & 1  & 0  & 0   \\
                                                                  & MemWrite    & 0        & 0  & 1  & 0   \\
                                                                  & Branch      & 0        & 0  & 0  & 1   \\
                                                                  & ALUOp1      & 1        & 0  & 0  & 0   \\
                                                                  & ALUOp0      & 0        & 0  & 0  & 1   \\
        \end{tabularx}
        \renewcommand{\arraystretch}{1}
        \setlength{\tabcolsep}{\oldtabcolsep}
    \end{footnotesize}
    \code{X}: Don't care

    \subsection{ALUOp}

    \begin{footnotesize}
        \renewcommand{\arraystretch}{1.2}
        \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}
        \begin{tabularx}{\linewidth}{@{}T Z Z Z T Z@{}}                                                                                                                \\
            Opcode                  & ALUOp               & Funct7  & Funct3 & ALU action                                              & ALU contr         \\
            \cmidrule{2-6}
            lw                      & 00                  & XXXXXXX & XXX    & add                                                     & 0010              \\
            sw                      & 00                  & XXXXXXX & XXX    & add                                                     & 0010              \\
            beq                     & 01                  & XXXXXXX & XXX    & sub                                                     & 0110              \\
            \multirow{4}{*}{R-type} & \multirow{4}{*}{10} & 0000000 & 000    & \color{teal} add                                        & \color{teal} 0010 \\
                                    &                     & 0100000 & 000    & \color{teal} sub                                        & \color{teal} 0110 \\
                                    &                     & 0000000 & 111    & \color{teal} and                                        & \color{teal} 0000 \\
                                    &                     & 0000000 & 110    & \color{teal} or                                         & \color{teal} 0001 \\
                                    &                     &         &        & \multicolumn{2}{c}{\color{teal} \tt{ALU control lines}}                     \\
        \end{tabularx}
        \renewcommand{\arraystretch}{1}
        \setlength{\tabcolsep}{\oldtabcolsep}
    \end{footnotesize}

    \subsection{Parallel Instruction Execution}

    To improve the performance of the CPU the idle time of each component is reduced. This can be achieved by:

    \begin{itemize}
        \item \textbf{Reuse} of logic units for different tasks (instructions).
        \item \textbf{Pipelining:} Executing multiple instructions at the same time (see~\ref{pipelining}).
        \item \textbf{Multi-issue processors} that fetch multiple instructions in each cycle (see~\ref{multi-issue processors}).
    \end{itemize}

    \subsubsection{Pipelining}\label{pipelining}

    \includegraphics[width=\linewidth]{cpu_pipelining.png}

    The CPU design is segmented into five sub-steps. Each segment performs an action of a different instruction.
    \newpar{}
    Dependencies between instructions produce three types of \textbf{Hazards}:
    \begin{itemize}
        \item~\ref{structural hazards} Structural Hazards
        \item~\ref{data hazards} Data Hazards
        \item~\ref{control hazards} Control Hazards
    \end{itemize}

    \paragraph{Structural Hazards}\label{structural hazards}

    \includegraphics[width=\linewidth]{cpu_pipelining_structural_hazard.png}

    Both steps need to access the memory. To fix this one can add more resources i.e. a block that only reads the instruction memory and another block that handles the read/write operations in the data memory.

    \begin{center}
        \includegraphics[width=0.5\linewidth]{cpu_pipelining_structural_hazard_fix.png}
    \end{center}

    \paragraph{Data Hazards}\label{data hazards}

    A subsequent instruction needs data or a register that is not yet ready.

    \begin{itemize}
        \item \textbf{RAW: read after write} (true dependency)
              \begin{lstlisting}[escapechar=@]
add @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t3, t4
sub t6, @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t5
\end{lstlisting}
        \item \textbf{WAR: write after read} (anti dependency)
              \begin{lstlisting}[escapechar=@]
add t1, @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t3
sub @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t4, t5
\end{lstlisting}
        \item \textbf{WAW: write after write} (output dependency)
              \begin{lstlisting}[escapechar=@]
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 100(t2)
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 200(t4)
\end{lstlisting}
    \end{itemize}

    The \textbf{WAR} and \textbf{WAW} hazard does not apply to the design showed at the beginning of this section. This is only an issue for Out-Of-Order CPU's.

    \newpar{}
    \ptitle{Solution for the RAW hazard}

    \paragraph{Control Hazards}\label{control hazards}

    \subsubsection{Multi-Issue Processors}\label{multi-issue processors}

    \paragraph{Static Multi-Issue Processors}

    \paragraph{Dynamic Multi-Issue Processors}

\end{multicols*}