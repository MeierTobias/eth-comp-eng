
\begin{multicols*}{2}
    \section{CPU Design}\label{cpu design}

    \begin{center}
        \includegraphics[width=\linewidth]{cpu_flowchart.png}
    \end{center}
    \subsection{Opcode}

    \begin{footnotesize}
        \renewcommand{\arraystretch}{1.2}
        \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}
        \begin{tabularx}{\linewidth}{@{}T T Z Z Z Z Z T @{}}\label{tab:opcode}
                                                                   & Signal name & R-format & lw & sw & beq & \color{teal}Stage                                              & NOP \\
            \cmidrule{2-6}
            \multirow{7}{*}{\begin{sideways}Input\end{sideways}}   & I[6]        & 0        & 0  & 0  & 1                                                                          \\
                                                                   & I[5]        & 1        & 0  & 1  & 1                                                                          \\
                                                                   & I[4]        & 1        & 0  & 0  & 0                                                                          \\
                                                                   & I[3]        & 0        & 0  & 0  & 0                                                                          \\
                                                                   & I[2]        & 0        & 0  & 0  & 0                                                                          \\
                                                                   & I[1]        & 1        & 1  & 1  & 1                                                                          \\
                                                                   & I[0]        & 1        & 1  & 1  & 1                                                                          \\
            \cmidrule{2-6}
            \morecmidrules\cmidrule{2-6}
            \multirow{10}{*}{\begin{sideways}Output\end{sideways}} & ALUSrc      & 0        & 1  & 1  & 0   & \multirow{3}{*}{\begin{sideways}\color{teal}EX\end{sideways}}        \\
                                                                   & ALUOp1      & 1        & 0  & 0  & 0   &                                                                      \\
                                                                   & ALUOp0      & 0        & 0  & 0  & 1   &                                                                      \\
            \cmidrule{2-7}
                                                                   & MemtoReg    & 0        & 1  & X  & X   & \multirow{3}{*}{\begin{sideways}\color{teal}MEM\end{sideways}} &     \\
                                                                   & RegWrite    & 1        & 1  & 0  & 0   &                                                                & 0   \\
                                                                   & MemRead     & 0        & 1  & 0  & 0   &                                                                & 0   \\
            \cmidrule{2-7}
                                                                   & MemWrite    & 0        & 0  & 1  & 0   & \multirow{3}{*}{\begin{sideways}\color{teal}WB\end{sideways}}  & 0   \\
                                                                   & Branch      & 0        & 0  & 0  & 1   &                                                                & 0   \\
        \end{tabularx}
        \renewcommand{\arraystretch}{1}
        \setlength{\tabcolsep}{\oldtabcolsep}
    \end{footnotesize}
    \newpar{}
    \code{X}: Don't care; \; {\color{teal} Pipeline stages}

    \subsection{ALUOp}

    \begin{footnotesize}
        \renewcommand{\arraystretch}{1.2}
        \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}
        \begin{tabularx}{\linewidth}{@{}T Z Z Z T Z@{}}
            Opcode                  & ALUOp               & Funct7  & Funct3 & ALU action                                              & ALU contr         \\
            \cmidrule{2-6}
            lw                      & 00                  & XXXXXXX & XXX    & add                                                     & 0010              \\
            sw                      & 00                  & XXXXXXX & XXX    & add                                                     & 0010              \\
            beq                     & 01                  & XXXXXXX & XXX    & sub                                                     & 0110              \\
            \multirow{4}{*}{R-type} & \multirow{4}{*}{10} & 0000000 & 000    & \color{teal} add                                        & \color{teal} 0010 \\
                                    &                     & 0100000 & 000    & \color{teal} sub                                        & \color{teal} 0110 \\
                                    &                     & 0000000 & 111    & \color{teal} and                                        & \color{teal} 0000 \\
                                    &                     & 0000000 & 110    & \color{teal} or                                         & \color{teal} 0001 \\
                                    &                     &         &        & \multicolumn{2}{c}{\color{teal} \tt{ALU control lines}}                     \\
        \end{tabularx}
        \renewcommand{\arraystretch}{1}
        \setlength{\tabcolsep}{\oldtabcolsep}
    \end{footnotesize}

    \subsection{Parallel Instruction Execution}

    To improve the performance of the single-cycle CPU the idle time of each component is reduced  $\to$ increase \textit{throughput}.. This can be achieved by:

    \begin{itemize}
        \item \textbf{Reuse} of logic units for different tasks (instructions).
        \item \textbf{Pipelining:} Executing multiple instructions at the same time (see~\ref{pipelining}).
        \item \textbf{Multi-issue processors} that fetch multiple instructions in each cycle (see~\ref{multi-issue processors}).
    \end{itemize}

    \textbf{Remark}

    Alternatively, the \textit{latency} i.e.\ the instruction length could be reduced too.

    \section{Pipelining}\label{pipelining}

    \includegraphics[width=\linewidth]{cpu_pipelining.png}

    The CPU design is segmented into five sub-steps. Each segment performs an action of a different instruction.

    \subsection{Pipeline Registers}
    Pipeline registers allow holding temporary information about different stages and forwarding necessary information in the pipeline.
    \begin{center}
        \includegraphics[width=\linewidth]{cpu_pipeline_reg.png}
    \end{center}

    \subsection{Control of CPU Elements}
    At the ID stage, the \textbf{per-stage control} of all stages is calculated based on the instruction.
    The control bits of the individual stages are then stored in an extension of the \textit{pipeline registers}, according to opcode in Table~\ref{tab:opcode}.
    \begin{itemize}
        \item[+] shorter clock cycle
        \item[+] fewer bits in the pipeline registers (instruction not passed along)
        \item[-] reduntant control information
    \end{itemize}

    \begin{center}
        \includegraphics[width=\linewidth]{cpu_pipelining_control.png}
    \end{center}

    \subsection{Hazards}
    Dependencies between instructions produce three types of \textbf{Hazards}:
    \begin{itemize}
        \item~\ref{structural hazards} Structural Hazards
        \item~\ref{data hazards} Data Hazards
        \item~\ref{control hazards} Control Hazards
    \end{itemize}

    \subsubsection{Structural Hazards}\label{structural hazards}

    \includegraphics[width=\linewidth]{cpu_pipelining_structural_hazard.png}

    Both steps need to access the memory. To fix this, individual resources can be added for the instruction memory and the data memory tasks.

    \begin{center}
        \includegraphics[width=0.3\linewidth]{cpu_pipelining_structural_hazard_fix.png}
    \end{center}

    \subsubsection{Data Hazards}\label{data hazards}

    A subsequent instruction needs data or a register that is not yet ready.

    \begin{itemize}
        \item \textbf{RAW:\ read after write} (true dependency)
              \begin{lstlisting}[escapechar=@]
add @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, t2, t3
sub t4, @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, t5
\end{lstlisting}
        \item \textbf{WAR:\ write after read} (anti dependency)
              \begin{lstlisting}[escapechar=@]
add t1, @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t3
sub @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t4, t5
\end{lstlisting}
        \item \textbf{WAW:\ write after write} (output dependency)
              \begin{lstlisting}[escapechar=@]
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 100(t2)
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 200(t4)
\end{lstlisting}
    \end{itemize}

    The \textbf{WAR} and \textbf{WAW} hazard does not apply to the design showed at the beginning of this section. This is only an issue for out-of-order CPU's.

    \newpar{}
    \ptitle{Detecting RAW hazards in the Pipeline}

    The pipeline registers can be used to check if an earlier instruction (later in the pipline) has data needed for the current instruction:
    If a current \code{src} register (\code{rs1/rs2}) is found in any later pipline register a data hazard exists.
    \begin{lstlisting}
PiplineID/EX.rs1/2 == PipelineEX/MEM.rd
PiplineID/EX.rs1/2 == PipelineMEM/WB.rd
    \end{lstlisting}
    \textbf{Remark}: This approach can lead to unnecessary forwarding when using store operations (already stored register is still detected in \code{PipelineMEM/WB.rd})

    \paragraph{Solution: Forwarding}
    By passing the result of the execution stage directly into the input of the next execution stage the \texttt{add}\textleftarrow\texttt{sub} RAW hazard can be avoided.

    \includegraphics[width=\linewidth]{cpu_pipelining_raw.png}

    The \textit{forwarding unit} decides which registers from which stages are used by the \textit{ALU}. This decision is affected and meant to resolve \textbf{data hazards}.

    \begin{center}
        \includegraphics[width=.7\linewidth]{cpu_pipelining_forwarding_simple.png}
    \end{center}

    \begin{footnotesize}
        \renewcommand{\arraystretch}{1.4}
        \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}
        \begin{tabularx}{\linewidth}{@{}T Z Z X @{}}
                                                                      & MUX Control   & Source & Explantion                             \\
            \cmidrule{2-4}
            \multirow{3}{*}{\begin{sideways}1.\ ALU op\end{sideways}} & ForwardA = 00 & ID/EX  & From register file                     \\
                                                                      & ForwardA = 10 & EX/MEM & From prior ALU result                  \\
                                                                      & ForwardA = 01 & MEM/WB & From data memory or earlier ALU result \\[1.5em]
            \multirow{3}{*}{\begin{sideways}2.\ ALU op\end{sideways}} & ForwardB = 00 & ID/EX  & From register file                     \\
                                                                      & ForwardB = 10 & EX/MEM & From prior ALU result                  \\
                                                                      & ForwardB = 01 & MEM/WB & From data memory or earlier ALU result \\
        \end{tabularx}
        \renewcommand{\arraystretch}{1}
        \setlength{\tabcolsep}{\oldtabcolsep}
    \end{footnotesize}

    \paragraph{Solution: Stalling}
    For some instructions this is insufficient. In these cases an extra stall/bubble step needs to be performed.

    \includegraphics[width=\linewidth]{cpu_pipelining_raw_stall.png}

    \ptitle{Remark:}
    The gray areas in the block diagram indicate the execution time inside one cycle (first half, second half or full cycle). A first half block can be executed in the same cycle as a second half block which reduces the number of bubbles.

    \newpar{}
    As mentioned in Table~\ref{tab:opcode}, setting the four bits (\code{Branch, RegWrite, MemWrite, MemRead}) to zero creates and pushes a \textbf{NOP} instruction into the pipline.
    Subsequently, the affected stages ``do nothing'' for a complete cycle and the PC is kept at the nect instruction.
    \begin{center}
        \includegraphics[width=\linewidth]{cpu_pipelining_NOP.png}
    \end{center}

    \subsubsection{Control Hazards}\label{control hazards}

    A branch instruction needs to be fully evaluated in order to know which instruction we need to execute next.

    \begin{lstlisting}[escapechar=@]
@\aftergroup\magentacodecolor@beq@\aftergroup\blackcodecolor@ t2, t5, 40
lw t6, 400(t0)
\end{lstlisting}

    There are three ways to solve this problem
    \begin{itemize}
        \item~\ref{bubble} Bubble
        \item~\ref{shortcut} Shortcut
        \item~\ref{prediction} Prediction
    \end{itemize}

    \paragraph{Bubble}\label{bubble}

    Wait until the outcome is known.
    \begin{itemize}
        \item[+] Simple design
        \item[$-$] Always two stalls
    \end{itemize}

    \includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_bubble.png}

    \paragraph{Shortcut}\label{shortcut}

    Wait less by adding additional logic to calculate the branch outcome sooner.

    \begin{itemize}
        \item[+] Simple design
        \item[$-$] Always one stalls
        \item[$-$] Needs more logic
    \end{itemize}

    \includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_shortcut_logic.png}

    \includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_shortcut.png}

    \paragraph{Prediction}\label{prediction}

    Predict the outcome of a branch instruction and roll back if the prediction was wrong.

    \newpar{}
    \ptitle{Pipeline Flush}

    Is a mechanism to clear out the executed parts of the followup instruction if the prediction was wrong. This has to happen before the downstream instructions reach the MEM or WB stage (DRAM corruption).
    \begin{center}
        \includegraphics[width=\linewidth]{cpu_pipeline_flush.png}
    \end{center}
    \newpar{}
    \ptitle{Static Prediction}

    Static prediction assumes that the branch is \textbf{not taken} and just continues with the next instruction. Due to the usage of loops this prediction is often \textbf{wrong}.

    \newpar{}
    \ptitle{Dynamic Prediction}

    The CPU learns which direction the branch takes. The predicition is based on the last (or multiple last) branch decision(s). %ChkTex 36
    \begin{center}
        \includegraphics[width=.5\linewidth]{cpu_pipelining_control_hazard_dyn_pred.png}
    \end{center}

    \newpar{}
    \ptitle{2-bit Dynamic Prediction}
    \begin{center}
        \includegraphics[width=.5\linewidth]{cpu_pipelining_control_hazard_dyn_pred_2bit.png}
    \end{center}

    This method operates well on nested loops (repeated execution of the same loop).

    \subsection{Multi-Issue Processors}\label{multi-issue processors}
    Multi-issue processors fetch multiple instructions in each cycle and try to execute them in parallel.
    \begin{itemize}
        \item This can be achieved by adding more (independent) pipelines, ALUs etc.
        \item As a result, multiple instrucitons per cycle (IPC) can be executed (IPC > 1)
    \end{itemize}
    \subsubsection{Static Multi-Issue Processors}
    The CPU fetches a \textbf{static number} of instructions at each cycle. AKA VLIW (Very Long Instruction Word)

    \includegraphics[width=\linewidth]{cpu_static_multi-issue_processors.png}

    The compiler ensures that all instructions fetched in the same cycle (packet) do not have any hazards with each other (no int\textcolor{red}{ra}-packet hazards). The CPU detects int\textcolor{red}{er}-packet hazards and handles them as needed.

    \subsubsection{Dynamic Multi-Issue Processors (Superscalar)}
    The processor decides how many instructions to fetch in each cycle. This depends on the available resources and hazards.
    \newpar{}
    \ptitle{Out-of-Order (OoO) Instruction Execution}

    OoO instruction execution allows to avoid certain hazards but requires a tracking of the dependencies between the instructions.
    \begin{center}
        \includegraphics[width=.8\linewidth]{cpu_multi-issue_processors_OoO.png}
    \end{center}

\end{multicols*}