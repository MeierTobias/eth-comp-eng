\section{Pipelining}\label{pipelining}

\includegraphics[width=\linewidth]{cpu_pipelining.png}

The CPU design is segmented into five sub-steps. Each segment performs an action of a different instruction.

\subsection{Pipeline Registers}
Pipeline registers allow holding temporary information about different stages and forwarding necessary information in the pipeline.
\begin{center}
    \includegraphics[width=\linewidth]{cpu_pipeline_reg.png}
\end{center}

\subsection{Control of CPU Elements}
At the ID stage, the \textbf{per-stage control} of all stages is calculated based on the instruction.
The control bits of the individual stages are then stored in an extension of the \textit{pipeline registers}, according to opcode in Table~\ref{tab:opcode}.
\begin{itemize}
    \item[+] shorter clock cycle
    \item[+] fewer bits in the pipeline registers (instruction not passed along)
    \item[-] redundant control information
\end{itemize}

\begin{center}
    \includegraphics[width=\linewidth]{cpu_pipelining_control.png}
\end{center}

\subsection{Hazards}
Dependencies between instructions produce three types of \textbf{Hazards}:
\begin{itemize}
    \item~\ref{structural hazards} Structural Hazards
    \item~\ref{data hazards} Data Hazards
    \item~\ref{control hazards} Control Hazards
\end{itemize}

\subsubsection{Structural Hazards}\label{structural hazards}

\includegraphics[width=\linewidth]{cpu_pipelining_structural_hazard.png}

Both steps need to access the memory. To fix this, individual resources can be added for the instruction memory and the data memory tasks.

\begin{center}
    \includegraphics[width=0.3\linewidth]{cpu_pipelining_structural_hazard_fix.png}
\end{center}

\subsubsection{Data Hazards}\label{data hazards}

A subsequent instruction needs data or a register that is not yet ready.

\begin{itemize}
    \item \textbf{RAW:\ read after write} (true dependency)
          \begin{lstlisting}[escapechar=@]
add @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, t2, t3
sub t4, @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, t5
\end{lstlisting}
    \item \textbf{WAR:\ write after read} (anti dependency)
          \begin{lstlisting}[escapechar=@]
add t1, @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t3
sub @\aftergroup\magentacodecolor@t2@\aftergroup\blackcodecolor@, t4, t5
\end{lstlisting}
    \item \textbf{WAW:\ write after write} (output dependency)
          \begin{lstlisting}[escapechar=@]
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 100(t2)
lw @\aftergroup\magentacodecolor@t1@\aftergroup\blackcodecolor@, 200(t4)
\end{lstlisting}
\end{itemize}

The \textbf{WAR} and \textbf{WAW} hazard does not apply to the design showed at the beginning of this section. This is only an issue for out-of-order CPU's.

\newpar{}
\ptitle{Detecting RAW hazards in the Pipeline}

The pipeline registers can be used to check if an earlier instruction (later in the pipeline) has data needed for the current instruction:
If a current \code{src} register (\code{rs1/rs2}) is found in any later pipeline register a data hazard exists.
\begin{lstlisting}
PipelineID/EX.rs1/2 == PipelineEX/MEM.rd
PipelineID/EX.rs1/2 == PipelineMEM/WB.rd
    \end{lstlisting}
\textbf{Remark}: This approach can lead to unnecessary forwarding when using store operations (already stored register is still detected in \code{PipelineMEM/WB.rd})

\paragraph{Solution: Forwarding}
By passing the result of the execution stage directly into the input of the next execution stage the \texttt{add}\textleftarrow\texttt{sub} RAW hazard can be avoided.

\includegraphics[width=\linewidth]{cpu_pipelining_raw.png}

The \textit{forwarding unit} decides which registers from which stages are used by the \textit{ALU}. This decision is affected and meant to resolve \textbf{data hazards}.

\begin{center}
    \includegraphics[width=.7\linewidth]{cpu_pipelining_forwarding_simple.png}
\end{center}

\begin{footnotesize}
    \renewcommand{\arraystretch}{1.4}
    \setlength{\oldtabcolsep}{\tabcolsep}\setlength\tabcolsep{6pt}

    \begin{tabularx}{\linewidth}{@{}T Z Z X @{}}
                                                                                 & MUX Control   & Source & Explanation                            \\
        \cmidrule{2-4}
        \multirow{3}{*}{\begin{sideways}\begin{scriptsize}1.\ ALU op\end{scriptsize}\end{sideways}} & ForwardA = 00 & ID/EX  & From register file                     \\
                                                                                 & ForwardA = 10 & EX/MEM & From prior ALU result                  \\
                                                                                 & ForwardA = 01 & MEM/WB & From data memory or earlier ALU result \\[1.5em]
        \multirow{3}{*}{\begin{sideways}\begin{scriptsize}2.\ ALU op\end{scriptsize}\end{sideways}} & ForwardB = 00 & ID/EX  & From register file                     \\
                                                                                 & ForwardB = 10 & EX/MEM & From prior ALU result                  \\
                                                                                 & ForwardB = 01 & MEM/WB & From data memory or earlier ALU result \\
    \end{tabularx}

    \renewcommand{\arraystretch}{1}
    \setlength{\tabcolsep}{\oldtabcolsep}
\end{footnotesize}

\paragraph{Solution: Stalling}
For some instructions this is insufficient. In these cases an extra stall/bubble step needs to be performed.

\includegraphics[width=\linewidth]{cpu_pipelining_raw_stall.png}

\ptitle{Remark:}
The gray areas in the block diagram indicate the execution time inside one cycle (first half, second half or full cycle). A first half block can be executed in the same cycle as a second half block which reduces the number of bubbles.

\newpar{}
As mentioned in Table~\ref{tab:opcode}, setting the four bits (\code{Branch, RegWrite, MemWrite, MemRead}) to zero creates and pushes a \textbf{NOP} instruction into the pipeline.
Subsequently, the affected stages ``do nothing'' for a complete cycle and the PC is kept at the next instruction.
\begin{center}
    \includegraphics[width=\linewidth]{cpu_pipelining_NOP.png}
\end{center}

\subsubsection{Control Hazards}\label{control hazards}

A branch instruction needs to be fully evaluated in order to know which instruction we need to execute next.

\begin{lstlisting}[escapechar=@]
@\aftergroup\magentacodecolor@beq@\aftergroup\blackcodecolor@ t2, t5, 40
lw t6, 400(t0)
\end{lstlisting}

There are three ways to solve this problem
\begin{itemize}
    \item~\ref{bubble} Bubble
    \item~\ref{shortcut} Shortcut
    \item~\ref{prediction} Prediction
\end{itemize}

\paragraph{Bubble}\label{bubble}

Wait until the outcome is known.
\begin{itemize}
    \item[+] Simple design
    \item[$-$] Always two stalls
\end{itemize}

\includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_bubble.png}

\paragraph{Shortcut}\label{shortcut}

Wait less by adding additional logic to calculate the branch outcome sooner.

\begin{itemize}
    \item[+] Simple design
    \item[$-$] Always one stalls
    \item[$-$] Needs more logic
\end{itemize}

\includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_shortcut_logic.png}

\includegraphics[width=\linewidth]{cpu_pipelining_control_hazard_shortcut.png}

\paragraph{Prediction}\label{prediction}
Predict the outcome of a branch instruction and roll back if the prediction was wrong.
\begin{itemize}
    \item The previous solutions waited for the branch outcome before the first action was taken.
    \begin{itemize}
        \item Now action is taken before the result is known.
    \end{itemize}
    \item In general: 
    \begin{itemize}
        \item Simple prediction needs less HW but is less reliable.
        \item Advanced prediction needs complex HW but is more reliable.
    \end{itemize}
\end{itemize}

\newpar{}
\ptitle{Pipeline Flush}

Is a mechanism to clear out the executed parts of the followup instruction if the prediction was wrong. This has to happen before the downstream instructions reach the MEM or WB stage (DRAM corruption).
\begin{center}
    \includegraphics[width=\linewidth]{cpu_pipeline_flush.png}
\end{center}
\newpar{}
\ptitle{Static Prediction}

Static prediction assumes that the branch is \textbf{not taken} and just continues with the next instruction. Due to the usage of loops this prediction is often \textbf{wrong}.

\newpar{}
\ptitle{Dynamic Prediction}

The CPU learns which direction the branch takes. The prediction is based on the last (or multiple last) branch decision(s). %ChkTex 36
\begin{center}
    \includegraphics[width=.5\linewidth]{cpu_pipelining_control_hazard_dyn_pred.png}
\end{center}

\newpar{}
\ptitle{2-bit Dynamic Prediction}
\begin{center}
    \includegraphics[width=.5\linewidth]{cpu_pipelining_control_hazard_dyn_pred_2bit.png}
\end{center}

\begin{itemize}
    \item This method operates well on nested loops (repeated execution of the same loop).
    \item Correct prediction becomes more important the deeper the pipeline is.
\end{itemize}


