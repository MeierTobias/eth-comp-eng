\section{Multiprocessing}
\subsection{Process Data structure}
A central data structure (``task'' in Linux) that keeps tracks of the processes' resources:
\begin{itemize}
    \item Page tables
    \item VMAs
    \item Registers (e.g.\ during exceptions)
\end{itemize}
The data structure gets updated when the process
\begin{itemize}
    \item Is first created
    \item Allocates/frees resources (e.g.\ heap)
    \item Gets scheduled in/out
    \item Dies
\end{itemize}

\ptitle{Process Data structure in Jake}
\begin{lstlisting}[style=bright_C++]
    enum PROCESS_STATUS {
        PROCESS_FREE_SLOT, 	// Slot free to be used
        PROCESS_RUNNING, 	    // Usermode runs process
        PROCESS_PAUSED, 	    // Process will be scheduled to run in usermode
        PROCESS_RESERVED,
    };

    struct process {
        unsigned int pid;
        enum PROCESS_STATUS status; // see enum PROCESS_STATUS
        struct node *uvmas;         // user VMAs
        struct trap_frame tf;       // user registers
        unsigned long satp;         // process' root PT
        unsigned long heap_end_vpn;
        struct elf_jake elf;        // where program instructions are stored
    };
\end{lstlisting}

\subsection{Starting a New Process}
\subsubsection{Executable Files}
\begin{itemize}
    \item Executables created by compiler
    \item ELF: Linux, Jake
    \item Portable Executable (PE): Windows
    \item Common OS: executables stored in SSD, link to OS
    \item Jake: stored directly in kernel (no file system): need to know all applications at kernel compilation
\end{itemize}
\ptitle{Application Linking in Jake}

\ptitle{Executable Linkable Format (ELF)}
\begin{center}
    \includegraphics[width = .5\linewidth]{ELF.png}
\end{center}
Defines where \texttt{.text}/\texttt{.data}/\texttt{.bss} sections
\begin{itemize}
    \item are located inside the executable file
    \item should be loaded in (virtual) memory
    \item \texttt{.text} entry address would define the first instruction of the program
\end{itemize} 
\ptitle{Preparing \texttt{.text} VMA in Jake}

\subsubsection{Starting the First Process}
Common OS start special first process (init process) which starts other processes. First, the specific process data structure must be initialized and then, one switches to user mode.
\ptitle{Process Data Structure}
\begin{itemize}
    \item Select a pid
    \item Copy the kernel page tables of the process (kernel is mapped to each user address space)
    \item Initialize the VMAs
    \item Information for the \texttt{.text} VMA
\end{itemize}

\ptitle{Switching to User Mode}
\begin{center}
    \includegraphics[width = \linewidth]{switch_user_mode.png}
\end{center}
To start a process, the kernel needs to know
\begin{itemize}
    \item the \texttt{.text} section of the application (where it lies)
    \item Address of 1st instruction (from ELF)
\end{itemize}
One can then switch to usermode after
\begin{itemize}
    \item Initializing user mode registers to zero (hide kernel registers)
    \item Set SEPC to first instruction of the program
    \item Set user-mode SP (can happen in kernel (e.g.\ Jake) or user-mode)
    \item call \texttt{sret}
\end{itemize}

\subsubsection{Multiprocessing}
Applications should be able to create new processes. Most kernels provide a system call called \textit{fork}:

\ptitle{Fork System Call}
\begin{itemize}
    \item Fork creates an \textbf{identical copy} of the address space of the calling process
    \begin{center}
        \includegraphics[width = \linewidth]{fork.png}
    \end{center}
    \item Forking process: parent
    \item New process: child
\end{itemize}
Just calling \textit{fork} can be useful sometimes (e.g.\ running same process on multiple CPUs) but to create a new process one must call \textit{exec}:

\ptitle{Exec System Call}
\begin{itemize}
    \item Typically called in the \textbf{child right after a fork}
    \item Replaces VMAs of child. 
    \item For \texttt{.text} VMA, it takes an executable file (e.g., ELF)
\end{itemize}
Example: exec in Jake
\begin{lstlisting}[style=bright_C++]
// a1: identifies next application to be run
// a2: main() argument for next process
// a3: return value
void scall_handler_execv()
{
    process_list[proc_running].status = PROCESS_PAUSED;     // pause current process
    tf_user->a0 = 0;            // success                                    
    proc_copy_frame(&process_list[proc_running].tf, tf_user);

    void *ptr__ = NULL;
    // next application to be run
    switch (tf_user->a1) {
    case 0:
        ptr__ = &_testing;
        break;
    case 1:
        ptr__ = &_hello_jr;
        break;
    default:
        printerr("ERROR: Non-existing application.\n");
        ecall_poweroff();
        break;
    }
    // call next app (won't return on success!)
    if (proc_run_process(ptr__, tf_user->a2, tf_user->a3) < 0) {
        // failure handling
        tf_user->a0 = -1;
        csrw(satp, process_list[proc_running].satp);
        pt_flush_tlb();
        process_list[proc_running].status = PROCESS_RUNNING;
    }
}
\end{lstlisting}
Note that fork and exec are merged into one system call in Jake.

\subsection{CPU Virtualization}
After creating the compatibility for running multiple processes one can virtualize the CPU. The idea of CPU virtualization is similar to memory virtualization:
\begin{itemize}
    \item Each processe should have illusion of having the entire CPU (kernel should create the illusion of infinite CPUs despite having only one or few)
    \item Software mechanism: context switch
    \item Policy: process scheduling
\end{itemize}
\subsubsection{Context Switching}
\ptitle{Context}
The designation ``context'' of a process means
\begin{itemize}
    \item Value of the registers
    \item Address space (described by VMAs)
    \item Page tables and physical pages (reachable through satp)
\end{itemize}
As VMAs and physical memory are preserved, only the CPU registers must be saved at context switch.

\subsubsection{Scheduling}
\paragraph{Round-Robin (RR) Scheduling}

\ptitle{Priority-Based RR}

\paragraph{Scheduling Modes}

\ptitle{Cooperative Scheduling}

\ptitle{Non-Cooperative Scheduling}

\paragraph{Timers}

