\section{Multiprocessing}
\subsection{Process Data structure}
A central data structure (``task'' in Linux) that keeps tracks of the processes' resources:
\begin{itemize}
    \item Page tables
    \item VMAs
    \item Registers (e.g.\ during exceptions)
\end{itemize}
The data structure gets updated when the process
\begin{itemize}
    \item Is first created
    \item Allocates/frees resources (e.g.\ heap)
    \item Gets scheduled in/out
    \item Dies
\end{itemize}

\ptitle{Process Data structure in Jake}
\begin{lstlisting}[style=bright_C++]
    enum PROCESS_STATUS {
        PROCESS_FREE_SLOT, 	// Slot free to be used
        PROCESS_RUNNING, 	    // Usermode runs process
        PROCESS_PAUSED, 	    // Process will be scheduled to run in usermode
        PROCESS_RESERVED,
    };

    struct process {
        unsigned int pid;
        enum PROCESS_STATUS status; // see enum PROCESS_STATUS
        struct node *uvmas;         // user VMAs
        struct trap_frame tf;       // user registers
        unsigned long satp;         // process' root PT
        unsigned long heap_end_vpn;
        struct elf_jake elf;        // where program instructions are stored
    };
\end{lstlisting}

\subsection{Starting a New Process}
\subsubsection{Executable Files}
\begin{itemize}
    \item Executables created by compiler
    \item ELF: Linux, Jake
    \item Portable Executable (PE): Windows
    \item Common OS: executables stored in SSD, link to OS
    \item Jake: stored directly in kernel (no file system): need to know all applications at kernel compilation
\end{itemize}
\ptitle{Application Linking in Jake}

\ptitle{Executable Linkable Format (ELF)}
\begin{center}
    \includegraphics[width = .5\linewidth]{ELF.png}
\end{center}
Defines where \texttt{.text}/\texttt{.data}/\texttt{.bss} sections
\begin{itemize}
    \item are located inside the executable file
    \item should be loaded in (virtual) memory
    \item \texttt{.text} entry address would define the first instruction of the program
\end{itemize} 
\ptitle{Preparing \texttt{.text} VMA in Jake}

\subsubsection{Starting the First Process}
Common OS start special first process (init process) which starts other processes. First, the specific process data structure must be initialized and then, one switches to user mode.
\ptitle{Process Data Structure}
\begin{itemize}
    \item Select a pid
    \item Copy the kernel page tables of the process (kernel is mapped to each user address space)
    \item Initialize the VMAs
    \item Information for the \texttt{.text} VMA
\end{itemize}

\ptitle{Switching to User Mode}
\begin{center}
    \includegraphics[width = \linewidth]{switch_user_mode.png}
\end{center}
To start a process, the kernel needs to know
\begin{itemize}
    \item the \texttt{.text} section of the application (where it lies)
    \item Address of 1st instruction (from ELF)
\end{itemize}
One can then switch to usermode after
\begin{itemize}
    \item Initializing user mode registers to zero (hide kernel registers)
    \item Set SEPC to first instruction of the program
    \item Set user-mode SP (can happen in kernel (e.g.\ Jake) or user-mode)
    \item call \texttt{sret}
\end{itemize}

\subsubsection{Multiprocessing}
Applications should be able to create new processes. Most kernels provide a system call called \textit{fork}:

\ptitle{Fork System Call}
\begin{itemize}
    \item Fork creates an \textbf{identical copy} of the address space of the calling process
    \begin{center}
        \includegraphics[width = 0.8\linewidth]{fork.png}
    \end{center}
    \item Forking process: parent
    \item New process: child
\end{itemize}
Just calling \textit{fork} can be useful sometimes (e.g.\ running same process on multiple CPUs) but to create a new process one must call \textit{exec}:

\ptitle{Exec System Call}
\begin{itemize}
    \item Typically called in the \textbf{child right after a fork}
    \item Replaces VMAs of child. 
    \item For \texttt{.text} VMA, it takes an executable file (e.g., ELF)
\end{itemize}
Example: exec in Jake
\begin{lstlisting}[style=bright_C++]
// a1: identifies next application to be run
// a2: main() argument for next process
// a3: return value
void scall_handler_execv()
{
    process_list[proc_running].status = PROCESS_PAUSED;     // pause current process
    tf_user->a0 = 0;            // success                                    
    proc_copy_frame(&process_list[proc_running].tf, tf_user);

    void *ptr__ = NULL;
    // next application to be run
    switch (tf_user->a1) {
    case 0:
        ptr__ = &_testing;
        break;
    case 1:
        ptr__ = &_hello_jr;
        break;
    default:
        printerr("ERROR: Non-existing application.\n");
        ecall_poweroff();
        break;
    }
    // call next app (won't return on success!)
    if (proc_run_process(ptr__, tf_user->a2, tf_user->a3) < 0) {
        // failure handling
        tf_user->a0 = -1;
        csrw(satp, process_list[proc_running].satp);
        pt_flush_tlb();
        process_list[proc_running].status = PROCESS_RUNNING;
    }
}
\end{lstlisting}
Note that fork and exec are merged into one system call in Jake.

\subsection{CPU Virtualization}
After creating the compatibility for running multiple processes one can virtualize the CPU. The idea of CPU virtualization is similar to memory virtualization:
\begin{itemize}
    \item Each processe should have illusion of having the entire CPU (kernel should create the illusion of infinite CPUs despite having only one or few)
    \item Software mechanism: context switch
    \item Policy: process scheduling
\end{itemize}
\subsubsection{Context Switching}
\begin{itemize}
    \item The process' context is \textbf{stored} in the \texttt{trap frame} data structure inside the process data structure.
    \item CPU cache needs to be flushed (contains old address space)
\end{itemize}

\ptitle{Context}

The designation ``context'' of a process means
\begin{itemize}
    \item Value of the registers
    \item Address space (described by VMAs)
    \item Page tables and physical pages (reachable through satp)
\end{itemize}
As VMAs and physical memory are preserved, only the CPU registers must be saved at context switch.

\subsubsection{Scheduling}
\paragraph{Round-Robin (RR) Scheduling}
\ptitle{Cooperative RR}

Go through the processes one by one and give each a chance to execute. In jake, one just walks the proccess list to find the next feasible process to implement RR.\\
Starvation in cooperative RR:
\begin{center}
    \includegraphics[width = .75\linewidth]{RR_motivation.png}
\end{center}
Some processes that only require short CPU time might suffer starvation (blue proccess).

\ptitle{Priority-Based RR}
Idea of automated priorization: kernel learns the processes' priorities. Every process starts at a high-priority priority, the kernel moves it to lower priorities if it uses the CPU too much.\\
Starvation in priority-based RR:
\begin{center}
    \includegraphics[width = .75\linewidth]{RR_prio_starvation.png}
\end{center}
To avoid this, one moves all jobs to high-priority queue once in a while.

\paragraph{Scheduling Modes}
The kernel needs to run to be able to make a scheduling decision. 

\ptitle{Cooperative (Non-Preemptive) Scheduling}

\begin{itemize}
    \item High-performance computing usually uses cooperative scheduling (less overhead).
    \item System call for cooperative scheduling: \texttt{yield}.
    \item On \texttt{yield}, the kernel performance a context switch to another proccess:
    \begin{enumerate}
        \item Store the registers in the old process trap frame
        \item Load the registers of the new process from its trap frame
        \item call \texttt{sret}
    \end{enumerate}
\end{itemize}
Pros/cons:
\begin{itemize}
    \item[+] Improved process performance
    \item[+] Simple
    \item[-] Process can \textbf{hog} CPU
    \item[-] Process is unaware of other processes: locally and globally suboptimal
\end{itemize}

\ptitle{Non-Cooperative (Preemptive) Scheduling}
\begin{itemize}
    \item Standard systems (e.g., phones, laptops, etc.) have non-cooperative scheduling (better responsiveness)
    \item Uses a timer connected to CPU to periodically generate \textbf{interrupts} (same as exception or trap)
    \item Kernel periodically preempts processes on each interrupt
    \item Exception handling: kernel checks on interrupt whether a context switch is necessary and executes it if 
\end{itemize}
Pros/cons:
\begin{itemize}
    \item[+] Process can't \textbf{hog} CPU
    \item[+] Increased responsiveness
    \item[-] Might cause negative performance impact
    \item[-] More complex
\end{itemize}

\paragraph{Timers}
\begin{itemize}
    \item External oscillator attached to CPU
\end{itemize}

\ptitle{Memory-Mapped I/O (MMIO)}

MMIO enables interaction with devices through memory accesses: access \textbf{device rather than DRAM}.

\ptitle{RISC-V QEMU Timers}

\begin{itemize}
    \item Current QEMU version only supports machine-mode timers
    \begin{itemize}
        \item Timers can only be configured in machine mode
        \item The interrupts will \textbf{always} be delivered to machine mode (non-maskable)
    \end{itemize}
    \item We need to mret to supervisor mode for scheduling
\end{itemize}
\begin{center}
    \includegraphics[width = .75\linewidth]{QEMU_timer.png}
\end{center}

